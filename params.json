{"name":"Roar","tagline":"A C++11/14 LINQ Implemention","body":"# roar\r\n\r\nA C++11/14 LINQ Implemention\r\n\r\n## Introduction\r\n\r\nA C++11/14 LINQ Implemention for fun!\r\n \r\n## Build Environment \r\n\r\n[Visual Studio 2013](http://www.visualstudio.com/) with [Visual C++ Compiler November 2013 CTP](http://aka.ms/Icp591)\r\n\r\n## Dependencies \r\n\r\n[Boost.Optional](http://www.boost.org/doc/libs/1_55_0/libs/optional/doc/html/index.html)\r\n\r\n[Microsoft::VisualStudio::CppUnitTestFramework](http://msdn.microsoft.com/en-us/library/hh598953.aspx)\r\n\r\n## Examples\r\n\r\nAll examples are based on [101 LINQ Samples](http://code.msdn.microsoft.com/101-LINQ-Samples-3fb9811b/viewsamplepack)\r\n\r\n### any\r\n\r\nThis sample uses Any to determine if any of the words in the array contain the substring 'ei'.\r\n\r\n```cpp\r\nstd::vector<std::string> words{ \"believe\", \"relief\", \"receipt\", \"field\" };\r\nbool i_after_e = roar::linq::from(words)\r\n  .any([](const std::string& s) {\r\n    return s.find(\"ie\") != std::string::npos;\r\n  });\r\n```\r\n\r\nThis sample uses Any to return a grouped a list of products only for categories that have at least one product that is out of stock.\r\n\r\n```cpp\r\nstruct product {\r\n  std::string product_name;\r\n  std::string category;\r\n  std::size_t unit_price;\r\n  bool operator==(const product& other) const {\r\n    return product_name == other.product_name &&\r\n      category == other.category &&\r\n      unit_price == other.unit_price;\r\n  }\r\n};\r\nstd::list<product> products{\r\n  { \"iphone\", \"cellphone\", 599 },\r\n  { \"nexus\", \"cellphone\", 499 },\r\n  { \"galaxy\", \"cellphone\", 499 },\r\n  { \"ipad\", \"pad\", 299 },\r\n  { \"nexus7\", \"pad\", 399 },\r\n  { \"galaxy\", \"pad\", 499 }\r\n};\r\nauto group = roar::linq::from(products)\r\n  .group_by([](const auto& p) { return p.category; })\r\n  .where([](const auto& g) {\r\n  return roar::linq::from(g).any([](const auto& i) {\r\n    return i.unit_price < 399;\r\n  });\r\n});\r\n```\r\n\r\n### all\r\n\r\nThis sample uses All to determine whether an array contains only odd numbers.\r\n\r\n```cpp\r\nstd::vector<int> numbers{ 1, 11, 3, 19, 41, 65, 19 };\r\nbool only_odd = roar::linq::from(numbers).all([](int i) { return i % 2 == 1; });\r\n```\r\n\r\nThis sample uses All to return a grouped a list of products only for categories that have all of their products in stock.\r\n\r\n```cpp\r\nstruct product {\r\n  std::string product_name;\r\n  std::string category;\r\n  std::size_t unit_price;\r\n  bool operator==(const product& other) const {\r\n    return product_name == other.product_name &&\r\n      category == other.category &&\r\n      unit_price == other.unit_price;\r\n  }\r\n};\r\nstd::list<product> products{\r\n  { \"iphone\", \"cellphone\", 599 },\r\n  { \"nexus\", \"cellphone\", 499 },\r\n  { \"galaxy\", \"cellphone\", 499 },\r\n  { \"ipad\", \"pad\", 299 },\r\n  { \"nexus7\", \"pad\", 399 },\r\n  { \"galaxy\", \"pad\", 499 }\r\n};\r\nauto group = roar::linq::from(products)\r\n  .group_by([](const auto& p) { return p.category; })\r\n  .where([](const auto& g) { \r\n    return roar::linq::from(g).all([](const auto& i) {\r\n      return i.unit_price > 399;\r\n    });\r\n  });\r\n```\r\n\r\n### average\r\n\r\nThis sample uses Average to get the average of all numbers in an array.\r\n\r\n```cpp\r\nstd::vector<int> numbers{ 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 };\r\nauto average = roar::linq::from(numbers).average();\r\n```\r\n\r\nThis sample uses Average to get the average length of the words in the array.\r\n\r\n```cpp\r\nstd::vector<std::string> words{ \"cherry\", \"apple\", \"blueberry\" };\r\nauto r = roar::linq::from(words).average([](const std::string& s) { return s.size(); });\r\n```\r\n\r\nThis sample uses Average to get the average price of each category's products.\r\n\r\n```cpp\r\nstruct product {\r\n  std::string product_name;\r\n  std::string category;\r\n  std::size_t unit_price;\r\n  bool operator==(const product& other) const {\r\n    return product_name == other.product_name &&\r\n      category == other.category &&\r\n      unit_price == other.unit_price;\r\n  }\r\n};\r\nstd::list<product> products{\r\n  { \"iphone\", \"cellphone\", 599 },\r\n  { \"nexus\", \"cellphone\", 499 },\r\n  { \"galaxy\", \"cellphone\", 699 },\r\n  { \"ipad\", \"pad\", 299 },\r\n  { \"nexus7\", \"pad\", 399 },\r\n  { \"galaxy\", \"pad\", 499 }\r\n};\r\n\r\nusing anonymous = struct dummy {\r\n  std::string category;\r\n  double average_price;\r\n  bool operator==(const dummy& other) {\r\n    return category == other.category && abs(average_price - other.average_price) < .00001;\r\n  }\r\n};\r\n\r\nauto grouped = roar::linq::from(products)\r\n  .group_by([](const auto& p) { return p.category; })\r\n  .select([](const auto& g) -> anonymous {\r\n    return { g.key, roar::linq::from(g).average([](const auto& i) { return i.unit_price; }) };\r\n});\r\n```\r\n\r\n### aggregate\r\n\r\nThis sample uses Aggregate to create a running product on the array that calculates the total product of all elements.\r\n\r\n``` cpp\r\nstd::vector<double> doubles{ 1.7, 2.3, 1.9, 4.1, 2.9 };\r\nauto product = roar::linq::from(doubles)\r\n  .aggregate([](double running, double next) { return running * next; });\r\n```\r\n\r\n### count\r\n\r\nThis sample uses Count to get the number of unique factors of 300.\r\n\r\n```cpp\r\nstd::vector<int> factors_of_300{ 2, 2, 3, 5, 5 };\r\nauto count = roar::linq::from(factors_of_300).count();\r\n```\r\n\r\nThis sample uses Count to get the number of odd ints in the array.\r\n\r\n```cpp\r\nstd::vector<int> numbers{ 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 };\r\nauto r = roar::linq::from(numbers).count([](int i) { return i % 2 == 1; });\r\n```\r\n\r\nThis sample uses Count to return a list of categories and how many products each has.\r\n\r\n```cpp\r\nstruct product {\r\n  std::string product_name;\r\n  std::string category;\r\n  std::size_t unit_price;\r\n  bool operator==(const product& other) const {\r\n    return product_name == other.product_name &&\r\n      category == other.category &&\r\n      unit_price == other.unit_price;\r\n  }\r\n};\r\nstd::list<product> products {\r\n  { \"iphone\", \"cellphone\", 599 },\r\n  { \"nexus\", \"cellphone\", 499 },\r\n  { \"galaxy\", \"cellphone\", 499 },\r\n  { \"ipad\", \"pad\", 299 },\r\n  { \"nexus7\", \"pad\", 399 },\r\n  { \"galaxy\", \"pad\", 499 }\r\n};\r\nusing anonymous = struct dummy {\r\n  std::string category;\r\n  size_t count;\r\n  bool operator==(const dummy& other) {\r\n    return category == other.category && count == other.count;\r\n  }\r\n};\r\nauto group = roar::linq::from(products)\r\n  .group_by([](const auto& p) { return p.category; })\r\n  .select([](const auto& g) -> anonymous {\r\n    return { g.key, roar::linq::from(g).count() };\r\n  });\r\n```\r\n\r\n### first\r\n\r\nThis sample uses First to return the first matching element as a Product, instead of as a sequence containing a Product.\r\n\r\n```cpp\r\nstruct product {\r\n  std::string name;\r\n  std::size_t type;\r\n};\r\nstd::list<product> l{\r\n  { \"nexus\", 5 },\r\n  { \"iphone\", 5 },\r\n  { \"galaxy\", 5 },\r\n  { \"galaxy\", 4 },\r\n  { \"iphone\", 4 },\r\n  { \"nexus\", 4 }\r\n};\r\nauto p = roar::linq::from(l)\r\n  .where([](const product& p) { return p.type == 4; }).first();\r\n```\r\n\r\nThis sample uses First to find the first element in the array that starts with 'o'.\r\n\r\n```cpp\r\nstd::vector<std::string> strings{ \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\" };\r\nauto starts_with_o = roar::linq::from(strings)\r\n  .first([](const std::string& s) { return s[0] == 'o'; });\r\n```\r\n\r\nThis sample uses FirstOrDefault to try to return the first element of the sequence, unless there are no elements, in which case the default value for that type is returned.\r\n\r\n```cpp\r\nstd::vector<int> numbers{};\r\nint first_or_default = roar::linq::from(numbers).first_or_default();\r\n```\r\n\r\n### group_by\r\n\r\nThis sample uses group by to partition a list of numbers by their remainder when divided by 5.\r\n\r\n```cpp\r\nstd::vector<int> numbers{ 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 };\r\nauto numnbers_groups = roar::linq::from(numbers).group_by([](int i) { return i % 5; });\r\n```\r\n\r\nThis sample uses group by to partition a list of words by their first letter.\r\n\r\n```cpp\r\nstd::vector<std::string> words{ \"blueberry\", \"chimpanzee\", \"abacus\", \"banana\", \"apple\", \"cheese\" };\r\nusing anonymous = struct dummy {\r\n  char key;\r\n  std::list<std::string> words;\r\n  bool operator==(const dummy& other) {\r\n    return key == other.key && words == other.words;\r\n  }\r\n};\r\nauto word_groups = roar::linq::from(words)\r\n  .group_by([](const std::string& s) { return s[0]; })\r\n  .select([](const auto& g) -> anonymous {\r\n    std::list<std::string> words;\r\n    std::for_each(std::begin(g), std::end(g), [&words](const auto& w) {\r\n      words.push_back(w);\r\n    });\r\n    return { g.key, words };\r\n  });\r\n```\r\n\r\nThis sample uses group by to partition a list of products by category.\r\n\r\n```cpp\r\nstruct product {\r\n  std::string product_name;\r\n  std::string category;\r\n  std::size_t unit_price;\r\n  bool operator==(const product& other) const {\r\n    return product_name == other.product_name &&\r\n      category == other.category &&\r\n      unit_price == other.unit_price;\r\n  }\r\n};\r\nstd::list<product> products{\r\n  { \"iphone\", \"cellphone\", 599 },\r\n  { \"nexus\", \"cellphone\", 499 },\r\n  { \"galaxy\", \"cellphone\", 499 },\r\n  { \"ipad\", \"pad\", 299 },\r\n  { \"nexus7\", \"pad\", 399 },\r\n  { \"galaxy\", \"pad\", 499 }\r\n};\r\n\r\nusing anonymous = struct dummy {\r\n  std::string category;\r\n  std::list<product> products;\r\n  bool operator==(const dummy& other) {\r\n    return category == other.category && products == other.products;\r\n  }\r\n};\r\nstd::list<product> grouped;\r\nauto order_groups = roar::linq::from(products)\r\n  .group_by([](const auto& p) { return p.category; })\r\n  .select([&grouped](const auto& g) -> anonymous {\r\n    grouped.clear();\r\n    std::for_each(std::begin(g), std::end(g), [&grouped](const auto& p) {\r\n      grouped.push_back(p);\r\n    });\r\n    return { g.key, grouped };\r\n});\r\n```\r\n\r\n### max\r\n\r\nThis sample uses Max to get the highest number in an array.\r\n\r\n```cpp\r\nstd::vector<int> numbers{ 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 };\r\nauto r = roar::linq::from(numbers).max();\r\n```\r\n\r\nThis sample uses Max to get the length of the longest word in an array.\r\n\r\n```cpp\r\nstd::vector<std::string> words{ \"cherry\", \"apple\", \"blueberry\" };\r\nauto shortest = roar::linq::from(words).max([](const std::string& w) { return w.size(); });\r\n```\r\n\r\n### min\r\n\r\nThis sample uses Min to get the lowest number in an array.\r\n\r\n```cpp\r\nstd::vector<int> numbers{ 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 };\r\nauto r = roar::linq::from(numbers).min();\r\n```\r\n\r\nThis sample uses Min to get the length of the shortest word in an array.\r\n\r\n```cpp\r\nstd::vector<std::string> words{ \"cherry\", \"apple\", \"blueberry\" };\r\nauto shortest = roar::linq::from(words).min([](const std::string& w) { return w.size(); });\r\n```\r\n\r\n### select\r\n\r\nThis sample uses select to return a sequence of just the names of a list of products.\r\n\r\n```cpp\r\nstruct product {\r\n  std::string name;\r\n  std::size_t type;\r\n};\r\nstd::list<product> l{ { \"nexus\", 5 }, { \"iphone\", 5 }, { \"galaxy\", 5 } };\r\nauto names = roar::linq::from(l).select([](const product& p) { return p.name; });\r\nAssert::IsTrue(std::equal(\r\n  std::begin(l),\r\n  std::end(l),\r\n  std::begin(names),\r\n  [](const product& p, const std::string& name) {\r\n    return p.name == name;\r\n  }\r\n));\r\n```\r\n\r\nThis sample combines select and where to make a simple query that returns the text form of each digit less than 5.\r\n\r\n```cpp\r\nstd::vector<int> numbers{ 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 };\r\nstd::vector<std::string> digits{ \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\" };\r\nauto r = roar::linq::from(numbers).where([](int i){ return i < 5; }).select([&digits](int i) { return digits[i]; });\r\n```\r\n\r\nThis sample uses select to produce a sequence of strings representing the text version of a sequence of ints.\r\n\r\n```cpp\r\nstd::vector<int> v{ 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 };\r\nstd::vector<std::string> strings{ \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\" };\r\nauto text_nums = roar::linq::from(v).select([&strings](int i) { return strings[i]; });\r\n```\r\n\r\nThis sample uses select to produce a sequence of the uppercase and lowercase versions of each word in the original array.\r\n\r\n```cpp\r\nstd::vector<std::string> v{ \"aPPLE\", \"BlUeBeRrY\", \"cHeRry\" };\r\nusing anonymous = struct { std::string upper; std::string lower; };\r\nauto upper_lower_words = roar::linq::from(v)\r\n  .select([](const std::string& s) -> anonymous {\r\n    auto upper = boost::to_upper_copy(s);\r\n    auto lower = boost::to_lower_copy(s);\r\n    return { upper, lower };\r\n});\r\n```\r\n\r\nThis sample uses select to produce a sequence containing text representations of digits and whether their length is even or odd.\r\n\r\n```cpp\r\nstd::vector<int> v{ 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 };\r\nstd::vector<std::string> strings{ \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\" };\r\nusing anonymous = struct { std::string digit; bool even; };\r\nauto digit_odd_evens = roar::linq::from(v)\r\n  .select([&strings](int i) -> anonymous {\r\n  return { strings[i], (i % 2 == 0) }; }\r\n);\r\n```\r\n\r\nThis sample uses select to produce a sequence containing some properties of Products, including UnitPrice which is renamed to Price in the resulting type.\r\n\r\n```cpp\r\nstruct product {\r\n  std::string product_name;\r\n  std::string category;\r\n  std::size_t unit_price;\r\n};\r\nstd::list<product> products{\r\n  { \"iphone\", \"cellphone\", 599 },\r\n  { \"nexus\", \"cellphone\", 499 },\r\n  { \"galaxy\", \"cellphone\", 499 }\r\n};\r\n\r\nusing anonymous = struct { std::string name; std::string category; std::size_t price; };\r\nauto r = roar::linq::from(products)\r\n  .select([](const product& p) -> anonymous {\r\n  \treturn{ p.product_name, p.category, p.unit_price };\r\n  });\r\n```\r\n\r\n\r\n### skip\r\n\r\nThis sample uses Skip to get all but the first 4 elements of the array.\r\n\r\n```cpp\r\nstd::vector<int> numbers{ 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 };\r\nauto r = roar::linq::from(numbers).skip(4);\r\n```\r\n\r\n### sum\r\n\r\nThis sample uses Sum to get the total of the numbers in an array.\r\n\r\n```cpp\r\nstd::vector<int> numbers{ 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 };\r\nauto r = roar::linq::from(numbers).sum();\r\n```\r\n\r\nThis sample uses Sum to get the total number of characters of all words in the array.\r\n\r\n```cpp\r\nstd::vector<std::string> words{ \"cherry\", \"apple\", \"blueberry\" };\r\nauto r = roar::linq::from(words).sum([](const std::string& word) { return word.size(); });\r\n```\r\n\r\n### sequence_equal\r\n\r\nThis sample uses EqualAll to see if two sequences match on all elements in the same order\r\n\r\n```cpp\r\nstd::vector<std::string> words1{ \"cherry\", \"apple\", \"blueberry\" };\r\nstd::vector<std::string> words2{ \"cherry\", \"apple\", \"blueberry\" };\r\nauto t = roar::linq::from(words1).sequence_equal(words2);\r\n\r\nstd::vector<std::string> words3{ \"apple\", \"blueberry\", \"cherry\" };\r\nauto f = roar::linq::from(words1).sequence_equal(words3);\r\n```\r\n\r\n### where\r\n\r\nThis sample uses where to find all elements of an array less than 5.\r\n\r\n```cpp\r\nstd::vector<int> numbers{ 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 };\r\nauto r = roar::linq::from(numbers).where([](int i) { return i < 5; });\r\n```\r\n\r\nThis sample uses where to find all products that are out of stock.\r\n\r\n```cpp\r\nstruct product {\r\n  std::string product_name;\r\n  std::string category;\r\n  std::size_t unit_price;\r\n  std::size_t units_in_stock;\r\n  bool operator==(const product& other) {\r\n    return product_name == other.product_name &&\r\n      category == other.category &&\r\n      unit_price == other.unit_price &&\r\n      units_in_stock == other.units_in_stock;\r\n  }\r\n};\r\nstd::list<product> products{\r\n  { \"iphone\", \"cellphone\", 599, 0 },\r\n  { \"nexus\", \"cellphone\", 499, 500 },\r\n  { \"galaxy\", \"cellphone\", 499, 800 }\r\n};\r\nauto r = roar::linq::from(products)\r\n  .where([](const product& p) {\r\n  return p.units_in_stock == 0;\r\n});\r\n```\r\n\r\nThis sample uses where to find all products that are in stock and cost more than 400 per unit.\r\n\r\n```cpp\r\nstruct product {\r\n  std::string product_name;\r\n  std::string category;\r\n  std::size_t unit_price;\r\n  std::size_t units_in_stock;\r\n  bool operator==(const product& other) {\r\n    return product_name == other.product_name &&\r\n      category == other.category &&\r\n      unit_price == other.unit_price &&\r\n      units_in_stock == other.units_in_stock;\r\n  }\r\n};\r\nstd::list<product> products{\r\n  { \"iphone\", \"cellphone\", 599, 0 },\r\n  { \"nexus\", \"cellphone\", 499, 500 },\r\n  { \"galaxy\", \"cellphone\", 399, 800 }\r\n};\r\nauto r = roar::linq::from(products)\r\n  .where([](const product& p) {\r\n  return p.units_in_stock > 0 && p.unit_price > 400;\r\n});\r\n```\r\n\r\n## License\r\n\r\nCopyright (c) 2014 bitdewy@gmail.com\r\n\r\nroar is licensed under the MIT Open Source license. For more information, see the [LICENSE](LICENSE) file in this repository.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}